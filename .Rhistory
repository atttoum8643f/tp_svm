install.packages("installr")
updateR()
library(installr)
updateR()
updateR()
data <- read.csv("data/Datagenus.csv", sep = ";", row.names = 1)
X <- as.matrix(data[-1001, 1:27])
n <- length(X[,1]) # dim var
W <- diag(1/n, n) # matrice de poids
I <- rep(1,n) # vec unitaire
cg <- function(X, W){
m <- t(X) %*% W %*% I # centre de gravité
return(m)
}
inertie <- sum(diag(t(Z) %*% W %*% Z))
data <- read.csv("data/Datagenus.csv", sep = ";", row.names = 1)
X <- as.matrix(data[-1001, 1:27])
n <- length(X[,1]) # dim var
W <- diag(1/n, n) # matrice de poids
I <- rep(1,n) # vec unitaire
cg <- function(X, W){
m <- t(X) %*% W %*% I # centre de gravité
return(m)
}
cg(X, W)
cr<- function(X){
n <- length(X[,1])
return(scale(X)*sqrt(n/(n-1))) # standardisation
}
Z <- cr(X)
inertie <- sum(diag(t(Z) %*% W %*% Z))
inertie
View(W)
View(X)
setwd("C:/Users/Happy/Desktop/MASTER2/apprentissage_statistiques/TP/tp_svm")
setwd("C:/Users/Happy/Desktop/MASTER2/apprentissage_statistiques/TP/tp_svm")
# la graine pour la reproductivité
set.seed(0808)
# Fonction d'estimation
estim_noyau <- function(n = 500, loi = function(n)rnorm(n), param = "gaussian") {
# Génération d'un échantillon
X <- loi(n)
# Estimation de densité
densit_noyau <- density(X, kernel = param)
return(densit_noyau)
}
# Fonction de tracé
plot_estim_noyau <- function(n=500, loi = function(n)rnorm(n),
densit_X = function(x) dnorm(x),
param = "gaussian", cex=1) {
# Génération d'un échantillon
X <- loi(n)
# Récupérer l'estimation
res <- estim_noyau(param, loi=loi, n=n)
# Tracé de la densité estimée
plot(res,
main = paste("Estimation de densité par noyau (noyau=", param, ")", sep=""),
xlab = "Valeurs de X",
ylab = "Densité",
lwd = 2, col = "navy", cex.main = cex)
# Ajout de la vraie densité (par défaut N(0,1))
curve(densit_X, add = TRUE, col = "red", lwd = 1.7)
}
# la graine pour la reproductivité
set.seed(0808)
# Afficher deux graphiques côte à côte
par(mfrow = c(1,2))
# vecteur de charactère pour les paramètres
par <- c("gaussian", "rectangular", "triangular","epanechnikov", "biweight", "cosine")
for (i in 1:6) {
# application de la fonction
plot_estim_noyau(param = par[i], cex = 0.62)
}
# Réinitialiser
par(mfrow = c(1,1))
mise_noyau <- function(n= 500, loi = function(n)rnorm(n),
densit_X = function(x) dnorm(x), param="gaussian", J=100, N=100, a=-5, b=5, h="nrd0"){
# Stocker les erreurs quadratiques intégrées
mse <- numeric(J)
# Pas de discrétisation (b-a)/K
dx <- (b - a) / N
for (j in 1:J) {
# Générer un estimateur sur un nouvel échantillon
X <- loi(n)
# Estimation de densité sur la grille
f_estim <- density(X, kernel = param, bw = h, from = a, to = b, n = N)
# Densité vraie aux mêmes points
f_true <- densit_X(f_estim$x)
# Intégrale discrète de l'erreur quadratique
mse[j] <- sum((f_estim$y - f_true)^2 * dx)
}
# Moyenne Monte Carlo = MISE
mise <- mean(mse)
return(mise)
}
# la graine pour la reproductivité
set.seed(8008)
# vecteur de charactère pour les paramètres
par <- c("gaussian", "rectangular","epanechnikov")
# boucle pour calculer la mise
for (s in 1:3) {
#application de la fonction mise_noyau
mise <- mise_noyau(  loi = function(n) rgamma(n, 3, 3),
densit_X = function(x) dgamma(x, 3, 3),param = par[s])
cat("La MISE pour le noyau", par[s], "est:", round(mise,6), "\n")
}
# la graine pour la reproductivité
set.seed(0088)
# Tracé de l'estimation de densité par noyau
plot_estim_noyau(
loi = function(n) rbeta(n, 2, 2),
densit_X = function(x) dbeta(x, 2, 2))
# Calcul de la MISE pour la loi beta
mise <- mise_noyau(
loi = function(n) rbeta(n, 2, 2),
densit_X = function(x) dbeta(x, 2, 2)
)
# Tracé de l'estimation de densité par noyau
plot_estim_noyau(
loi = function(n) rgamma(n, 3, 3),
densit_X = function(x) dgamma(x, 3, 3))
# Calcul de la MISE pour la loi Gamma
mise <- mise_noyau(
loi = function(n) rgamma(n, 3, 3),
densit_X = function(x) dgamma(x, 3, 3)
)
set.seed(0808)
# Densité Laplace(0,1)
dlaplace <- function(x) {
0.5 * exp(-abs(x))
}
# Génération Laplace(0,1)
rlaplace <- function(n) {
u <- runif(n, -0.5, 0.5)
-sign(u) * log(1 - 2*abs(u))
}
# Tracé de l'estimation de densité par noyau
plot_estim_noyau(loi = rlaplace,
densit_X = dlaplace)
# Calcul de la MISE pour la loi de Laplace
mise <- mise_noyau(loi = rlaplace,
densit_X = dlaplace, a=-8, b=7)
estim_faisceau <- function(n=500, k=50, hmin=0.05, hmax=1.0, taille=0.8, param="gaussian"){
X <- rnorm(n) # échantillon gaussien standard
# Intervalle de h (bandwidth)
h_seq <- seq(hmin, hmax, length.out = k)
# Faisceau d'estimateurs
plot(NULL, xlim = c(-4.3,4.3), ylim = c(-0.08,0.52),
xlab = "x", ylab = "densité",
main = paste("Faisceau d'estimateurs (n=", n,", h est dans [", hmin, ",", hmax, "])",
sep=""), cex.main = 0.65)
# densité vraie
curve(dnorm(x), from=-4, to=4, col="red", lwd=3.5, add=TRUE)
# Faisceau en gris clair
for (h in h_seq) {
d_est <- density(X, kernel=param, bw=h, from=-4, to=4)
lines(d_est, col=rgb(0.7,0.7,0.7,0.5))
}
# Trois méthodes automatiques de R
bw_bcv <- density(X, bw="bcv", kernel=param, from=-4, to=4)
bw_ucv  <- density(X, bw="ucv",  kernel=param, from=-4, to=4)
bw_SJ   <- density(X, bw="SJ",   kernel=param, from=-4, to=4)
lines(bw_bcv, col="blue", lwd=2.5, lty=4)
lines(bw_ucv,  col="green", lwd=2.7, lty=2)
lines(bw_SJ,   col="purple", lwd=2.9, lty=3)
legend("topright", legend=c("Vraie densité","bcv","ucv","SJ"),
col=c("red","blue","green","purple"), lty=1, lwd=3, cex = taille)
}
# La graine pour la reproductivité
set.seed(0808)
# Afficher deux graphiques côte à côte
par(mfrow = c(1,2))
estim_faisceau(hmin=0.05, hmax=0.3, taille = 0.3)
estim_faisceau(hmin = 0.29, hmax = 0.55, taille = 0.4)
estim_faisceau(hmin=0.6, hmax = 1, taille = 0.4)
estim_faisceau(hmin = 1.35, hmax = 1.8, taille = 0.4)
par(mfrow = c(1,1))
# La graine pour la reproductivité
set.seed(0808)
# Afficher deux graphiques côte à côte
par(mfrow = c(1,2))
estim_faisceau(hmin=0.05, hmax=0.3, taille = 0.3)
estim_faisceau(hmin = 0.29, hmax = 0.55, taille = 0.4)
estim_faisceau(hmin=0.6, hmax = 1, taille = 0.4)
estim_faisceau(hmin = 1.35, hmax = 1.8, taille = 0.4)
par(mfrow = c(1,1))
# La graine pour la reproductivité
set.seed(0808)
# Afficher deux graphiques côte à côte
par(mfrow = c(1,2))
estim_faisceau(hmin=0.05, hmax=0.3, taille = 0.3)
estim_faisceau(hmin = 0.29, hmax = 0.55, taille = 0.4)
estim_faisceau(hmin=0.6, hmax = 1, taille = 0.4)
estim_faisceau(hmin = 1.35, hmax = 1.8, taille = 0.4)
par(mfrow = c(1,1))
setwd("C:/Users/Happy/Desktop/MASTER2/apprentissage_statistiques")
setwd("C:/Users/Happy/Desktop/MASTER2/apprentissage_statistiques/TP/tp_svm")
